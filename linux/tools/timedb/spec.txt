
                    Time series DB specification

Why not RRD?
============

While RRD's idea seems good, its realization heavily sucks, really! The maximum
storage interval is 1s, the API is a nightmare (one needs to concatenate strings
that contain the value for storing) and it does not seem suited for
high-performance. The internal storage format has no concrete specification
and is quite intransparent. Reverse-engineering the rrdtool might rather be
a waste of time. Also, data compression is not always desired. Ideally, there
is a specification that is easy, simple and independent from the actual
implementation. Just like the Pcap file format. Then, this could also be used
for lightweight implementations on embedded devices (without having library
dependencies).

Benefits of timedb:
===================

	* High-precision (in data and time)
	* High-performance
	* Static database size over time (round robin)
	* Transparent database layout
	* Implementation possible without libraries
	* Standard format for all timedbs

Architecture:
=============

File Header:
------------

struct timedb_timeval {
	uint32_t tv_sec;
	uint32_t tv_usec;
} __packed;

struct timedb_hdr {
	uint32_t canary;
	uint8_t version_major;
	uint8_t version_minor;
	struct timedb_timeval start;
	uint64_t interval;
	uint64_t block_entries;
	uint16_t cells_per_block;
	uint64_t offset_next;
	uint64_t seq_next;
} __packed;

Field description:

	- canary: is a field to identify the beginning of the file (default:0xdeadbeef)
	- version_major: as the name says, it's the major version number (default:1)
	- version_minor: as the name says, it's the minor version number (default:0)
	- start: start time, taken from a timeval
	- interval: is the expected interval data arrives in us
	- block_entries: number of total entries to allocate (before wrap around)
	- cells_per_block: number of columns per row, including seq field
	- offset_next: next file offset to write data to
	- seq_next: next sequence number

Data:
-----

Data is saved as array of 64-Bit floats. If cells_per_row is 4, then a data
block looks like:

struct my_block {
	uint64_t seq;
	float64_t cells[3];
} __packed;

Have a look at the reference implementation in within this directory. After
<block_entries> have been written into the database, there is a turnaround
and the next block overwrites the oldest one. So the sequence number defines
the distance in <interval> * <block.seq> from <start> assuming that data has
been written in accordance to timing constraints.

Example:
========

	$ timedb_create foo.tdb 1000 10 2
	$ timedb_dump foo.tdb
	$ timedb_update foo.tdb 3.0 5.0
	$ ...
	$ timedb_dump foo.tdb
