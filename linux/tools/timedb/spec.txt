
                    Time series DB specification

Why not RRD?
============

While RRD's idea seems good, its realization heavily sucks, really! The maximum
storage interval is 1s, the API is a nightmare (one needs to concatenate strings
that contain the value for storing) and it does not seem suited for
high-performance. The internal storage format has no concrete specification
and is quite intransparent. Reverse-engineering the rrdtool might rather be
a waste of time. Also, data compression is not always desired. Ideally, there
is a specification that is easy, simple and independent from the actual
implementation. Just like the Pcap file format. Then, this could also be used
for lightweight implementations on embedded devices (without having library
dependencies).

Architecture:
=============

File Header:
------------

struct timedb_timeval {
	uint32_t tv_sec;
	uint32_t tv_usec;
} __packed;

struct timedb_hdr {
	uint32_t canary;
	uint8_t version_major;
	uint8_t version_minor;
	struct timedb_timeval start;
	uint64_t interval;
	uint64_t block_entries;
	uint16_t cells_per_block;
	uint64_t offset_next;
	uint64_t seq_next;
} __packed;

Field description:

	- canary: is a field to identify the beginning of the file (default:0xdeadbeef)
	- version_major: as the name says, it's the major version number (default:1)
	- version_minor: as the name says, it's the minor version number (default:0)
	- interval: is the expected interval data arrives in us
	- start: start time, taken from a timeval
	- block_entries: number of total entries to allocate (before wrap around)
	- cells_per_block: number of columns per row, excluding seq field
	- offset_next: next file offset to write data to
	- seq_next: next sequence number

Data:
-----

Data is saved as array of 64-Bit floats. If cells_per_row is 3, then a data
block looks like:

struct my_block {
	uint64_t seq;
	float64_t cell[3];
} __packed;
